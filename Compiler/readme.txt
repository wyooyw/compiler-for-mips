增加了字符和字符串的错误处理
增加了初始字符不认识的错误处理

字符增加了加减法和乘除法(之前只有加法和乘法)

增加了右中括号错误的判断

增加了分号消失的判断
语句->空语句的分号消失怎么办？？？
还有变量定义最后的if里对分号的判断？？？只要不是赋值符号，都进入<变量定义无初始化>

增加了右括号
值参数表的tryword的右括号怎么判断？？？
参数表？？？当下一个单词不是右小括号时，还要判断是否是左大括号

增加了switch中缺少defalt时的报错
增加了数组初始化个数不匹配

编写符号类和符号表类
注意符号名称全都要小写，总共最多10000个符号，符号名长最多50
在变量定义中，编写了名字重定义的错误提示，编写了加入符号表
在无返回值函数定义、有返回值函数定义和main函数中，操作了level变量的++和--（应该还有大括号括起来的语句列？？？？？？？？？）
遇到爆栈问题。C++对象成员变量如何放到堆中？？？
在常量定义中，编写了名字重定义的错误提示，编写了加入符号表
应该在Word类中添加一个smallword属性，用来存小写版本？？？？？？
编写了有返回值函数、无返回值函数的加入符号表操作（以及检查名字是否重定义）
main函数符号表还没写？？？？
函数符号表中参数信息回填
符号表打印展示


增加了函数定义中参数加入符号表的操作
增加了退出函数时将之前的valid给设置为0的操作
增加了main函数的符号表操作
在语法分析器中新增“引用标识符”类型语法
引用标识符所在的文法：<因子>，<赋值语句>,<循环语句>的for循环，<有返回值的函数调用语句>
						，<无返回值的函数调用语句>，读语句
增加了引用未定义符号的错误提示
增加了“函数参数个数不匹配”、“函数参数类型不匹配”
表达式增加了综合属性：类型	只有单独一个字符型时，表达式是字符型；否则全是整型。
增加了“条件判断中出现不合法的类型”
增加了判断数组下标是否是整数的错误提示
“创建标识符”类型语法？？？？？？
动作符号类？？？？？把动作从SignTable和GrammarAnalyser中剥离出来？？？？？
建立定长数组长度的宏定义统一位置？？？

修bug
增加了判断数组下标是否是整数的错误提示
增加了<常量>类型不一致的错误提示 包括：变量定义及初始化，常量定义，switch
增加了“不能改变常量的值”的错误提示，包括：赋值语句、scanf
为单词增加了smallword
将“单词长度”定义到了统一的宏定义
修改输出文件为“error.txt”
一个有返回值的函数里只有一个有报错的返回语句，算没有返回语句吗？？？？？
添加了“无返回值的函数存在不匹配的return语句”和“有返回值的函数缺少return语句或存在不匹配的return语句”
('a')算数字


语义分析 生成中间代码
1.创建符号的时候为其创建id
2.为sign的base属性赋值
3.舍弃level(慎重)
4.若出现比2^16大的数，应先用lui
5.解析AST的时候设置符号表的current
6.临时寄存器一定要及时释放，因为临时寄存器不能写回内存，不释放会一直占着寄存器空间。
7.数据流分流时，需要备份当前寄存器环境；合并时，需要恢复到备份状态。
8.switch语句，应将多个case对应的跳转语句(beq)挨着写：
beq $t0,$t1,case1
beq $t0,$t2,case2
beq $t0,$t3,case3
...
j $default

case1:
....

case2:
....

而不是写成多个“if-elseif-elseif”的形式。否则如果遇到嵌套32层的switch语句，寄存器就被占满了就爆了。
9.设置ASTNode指针，初始化不要为0，在错误处理时不要崩。可以设置一个“空符号”。
10.退出函数时的寄存器释放操作，可以简化（只free，不sw）
11.表达式设置一种模式，指定存储结果的寄存器，而不是每次先存进临时寄存器，再倒腾一次。
12.main函数里有return时，读取的ra为0会出错。
13.改了sp寄存器的顺序，可能有些地方会错位4个字节。
14.t_factor 非叶子节点，申请rst寄存器时，若之前的t_factor的right的寄存器是变量寄存器，可能被释放掉。
15.变量寄存器每被load一次，都更改调用时间。
16.mips的临时内存需要释放，不然小心栈溢出。
17.14的问题也可能在assign中出现。
18.C语言 栈使用的空间有点多
19.sp开到0x7ff0000000

20.存到内存的临时寄存器用完也及时释放，避免变量寄存器被释放，也可减去没用的“存回内存”.